# Оптимизация проекта по принципам SOLID

Проект был рефакторирован с применением принципов SOLID для улучшения поддерживаемости, расширяемости и тестируемости кода.

## Примененные принципы SOLID

### 1. Single Responsibility Principle (SRP) - Принцип единственной ответственности

**Проблема:** Компоненты выполняли несколько задач одновременно.

**Решение:**
- ✅ **`hooks/useTheme.ts`** - отдельный хук для управления темой
- ✅ **`hooks/useClipboard.ts`** - отдельный хук для операций с буфером обмена
- ✅ **`pages/HomePage.tsx`** - отдельный компонент для главной страницы
- ✅ **`components/ui/CopyButton.tsx`** - переиспользуемый компонент кнопки копирования
- ✅ **`components/ui/BankAccountField.tsx`** - переиспользуемый компонент поля банковского счета
- ✅ **`constants/bankAccount.ts`** - константы банковского счета вынесены отдельно

**Результат:** Каждый компонент/хук отвечает за одну конкретную задачу.

### 2. Open/Closed Principle (OCP) - Принцип открытости/закрытости

**Проблема:** Добавление новых страниц требовало изменения `App.tsx`.

**Решение:**
- ✅ **`routing/PageRouter.tsx`** - роутер страниц, который можно расширять без изменения основного кода
- ✅ Новые страницы добавляются через `PageRouter`, не требуя изменений в `App.tsx`

**Результат:** Система открыта для расширения, но закрыта для модификации.

### 3. Liskov Substitution Principle (LSP) - Принцип подстановки Лисков

**Применено:**
- ✅ Компоненты страниц имеют единый интерфейс и могут заменять друг друга
- ✅ Переиспользуемые UI компоненты (`CopyButton`, `BankAccountField`) следуют единым контрактам

### 4. Interface Segregation Principle (ISP) - Принцип разделения интерфейсов

**Решение:**
- ✅ **`interfaces/ITranslationService.ts`** - интерфейсы разделены по функциональности
- ✅ Компоненты получают только необходимые пропсы

**Результат:** Компоненты не зависят от интерфейсов, которые не используют.

### 5. Dependency Inversion Principle (DIP) - Принцип инверсии зависимостей

**Проблема:** Прямые зависимости от конкретных реализаций.

**Решение:**
- ✅ Компоненты зависят от хуков (абстракций), а не от конкретной реализации
- ✅ **`interfaces/ITranslationService.ts`** - абстракции для сервисов
- ✅ Использование хуков вместо прямого обращения к `localStorage` и `navigator.clipboard`

**Результат:** Высокоуровневые модули не зависят от низкоуровневых.

## Структура проекта после оптимизации

```
dom-ojca-wrocław/
├── components/
│   ├── ui/                    # Переиспользуемые UI компоненты
│   │   ├── CopyButton.tsx
│   │   └── BankAccountField.tsx
│   ├── DonationPage.tsx      # Оптимизирован с использованием хуков
│   └── ...
├── hooks/                     # Кастомные хуки (SRP)
│   ├── useTheme.ts
│   └── useClipboard.ts
├── pages/                     # Страницы приложения
│   └── HomePage.tsx
├── routing/                   # Роутинг (OCP)
│   └── PageRouter.tsx
├── constants/                 # Константы
│   └── bankAccount.ts
├── interfaces/                # Интерфейсы (DIP)
│   └── ITranslationService.ts
└── App.tsx                    # Упрощенный главный компонент
```

## Преимущества оптимизации

1. **Поддерживаемость:** Код легче понимать и изменять
2. **Тестируемость:** Компоненты и хуки можно тестировать изолированно
3. **Переиспользование:** Компоненты можно использовать в разных местах
4. **Расширяемость:** Легко добавлять новые страницы и функции
5. **Читаемость:** Четкое разделение ответственности

## Примеры использования

### Использование хука темы:
```typescript
const { isDarkMode, toggleTheme } = useTheme();
```

### Использование хука буфера обмена:
```typescript
const { copied, copyToClipboard } = useClipboard();
```

### Добавление новой страницы:
1. Добавить `PageView.NEW_PAGE` в `types.ts`
2. Добавить case в `PageRouter.tsx`
3. Создать компонент страницы
4. Добавить переводы в `translations.ts`

## Следующие шаги для дальнейшей оптимизации

1. Добавить unit-тесты для хуков и компонентов
2. Создать Storybook для UI компонентов
3. Добавить валидацию форм через отдельный сервис
4. Вынести конфигурацию в отдельные файлы
5. Добавить error boundaries для обработки ошибок
